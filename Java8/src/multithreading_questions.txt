1.What is the difference between calling run() and start() for a thread?
 Explanation:
     Calling start() creates a new thread and executes the run() method in that thread.
     Calling run() directly executes the code in the current thread without starting a new thread.
start()-----
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // Starts a new thread
        System.out.println("Main thread continues...");
    }
}

--
Main thread continues...
Thread is running...
--run()
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.run(); // Calls run() in the main thread
        System.out.println("Main thread continues...");
    }
}
Thread is running...
Main thread continues...
/////
2. What Happens If You Call Wait() Outside a Synchronized Block?
Explanation:
Calling wait() outside a synchronized block results in IllegalMonitorStateException because wait() must be called with a lock acquired.
///
3. Can a Constructor Be Synchronized?
Explanation:
No, constructors cannot be synchronized because object locks do not exist until the object is created. However, synchronized blocks can be used inside constructors.
///
4. What Happens If You Return From Try or Catch? Will Finally Execute?
Explanation:
Yes, the finally block always executes, even if there is a return statement inside try or catch. However, if finally also has a return, it overrides other return values.
///
5. What Happens If an Exception Is Thrown in Finally?
Explanation:
Exceptions in the finally block suppress exceptions from the try or catch blocks.
public class Test {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
        } catch (Exception e) {
            System.out.println("Catch executed");
        } finally {
            throw new RuntimeException("Exception in finally");
        }
    }
}
--Exception in finally

//
6.Why have a CompletableFuture when we have an ExecutorService ?
Consider the following example:

public static Integer add(int a, int b) {
        return a + b;

    }
public static Integer multiply(int result) {
    return result * 15;
}
I want to add two numbers using add method in one thread and want to pass the result to another thread whose sole purpose
is to multiply the number by 15 using the multiply method. When the first task is finished by the first thread, I want to pass the result of the first task to another thread. Let us see how we can achieve this with ExecutorService.

 static class Add implements Callable<Integer> {
        int a;
        int b;
        Add(int a, int b) {
            this.a = a;
            this.b = b;
        }
        @Override
        public Integer call() throws Exception {
            return a + b;
        }
    }

    static class Multiply implements Callable<Integer> {
        int result;
        Multiply(int result) {
            this.result = result;
        }
        @Override
        public Integer call() throws Exception {
            return result * 10;
        }
    }

We would be requiring two tasks implementing Callable. Now, in the main method, we would be creating ExecutorService like the one below.

public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // will write code here

}

Now, we will be submitting our task to this ExecutorService

 public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        Future<Integer> futureResult = executor.submit(new Add(10, 20)); // 1
        Integer intermediateResult = futureResult.get(); // 2
        Future<Integer> finalResult = executor.submit(new Multiply(intermediateResult)); // 3
        System.out.println(finalResult.get());
        executor.shutdown();
    }

First, we have submitted Add task which will provide us with Future<Integer>.

Now, at line number 2, we need to provide a blocking call to get() to fetch the result in the main thread.
Now it’s the responsibility of the main thread to pass the result of this to another thread using ExecutorService submit method at line number 3.

We get the Future<Integer>, and we finally print the result. To summarize, we require a main thread whose responsibility is
to submit the task so that the task can be carried out in another thread(pool of threads). The main thread will call the blocking method
to fetch the result and will then submit the intermediate result to the ExecutorService. Not interesting at all.

Now, consider that I have 10 pairs of integers for which I have to add, and the result needs to be multiplied by 10 in another thread. My code will be like this:

  ExecutorService executor = Executors.newFixedThreadPool(3);
        List<Future<Integer>> finalFutureList = new ArrayList<>();
        List<Integer> finalResultList = new ArrayList<>();
        for(int i=0; i<10; i++){
            Future<Integer> futureResult = executor.submit(new Add(RandomUtils.nextInt(), RandomUtils.nextInt())); //1
            Integer intermediateResult = futureResult.get(); // 2
            Future<Integer> finalResult = executor.submit(new Multiply(intermediateResult));
            finalFutureList.add(finalResult);
        }
        for(Future<Integer> future : finalFutureList){
            finalResultList.add(future.get());
        }
        System.out.println(finalFutureList);
        executor.shutdown();

We are able to achieve the above through looping. Consider i = 0, we are at line 2, suppose this is taking time, and due to this,
we cannot proceed to i = 1. Ideally, we would like all 10 processes to work in parallel, and inside each process, when one task is finished,

without the help of the main thread, the result should be pushed to another thread so that it can carry out its task for which it is dependent.

This is where CompletableFuture APIs come in. Consider the code below

public static void main(String[] args) throws ExecutionException, InterruptedException {
    Integer finalResult = CompletableFuture.supplyAsync(() -> add(10, 20))
            .thenApplyAsync(result -> multiply(result))
            .get();
    System.out.println(finalResult);
}
public static Integer add(int a, int b) {
    return a + b;

}
public static Integer multiply(int result) {
    return result * 15;
}

Simple and concise, We provided the first task with supplyAsync and chained it with thenApply. When the task in supplyAsync is finished,
it will automatically transfer the result to thenApply function. On top of it, we can also provide the Thread pool in which these tasks need to be run like below:

 ExecutorService executorService = Executors.newFixedThreadPool(3);
        Integer finalResult = CompletableFuture.supplyAsync(() -> add(10, 20),executorService)
                .thenApplyAsync(result -> multiply(result),executorService)
                .get();
        System.out.println(finalResult);

Let us consider that if we have 10 pairs of integers and we have to perform all these 10 processes in parallel,
 each process contains two tasks performed in a separate thread, but task 2 depends on task 1.

public static void main(String[] args) throws ExecutionException, InterruptedException {
  ExecutorService executorService = Executors.newFixedThreadPool(3);
  List<CompletableFuture> list = new ArrayList<>();
  List<Integer> finalResult = new ArrayList<>();

  for(int i=0; i < 10; i++){
    list.add(CompletableFuture.supplyAsync(() -> add(RandomUtils.nextInt(), RandomUtils.nextInt()),executorService)
       .thenApplyAsync(result -> multiply(result),executorService));

  }
  for(CompletableFuture<Integer> future : list){
      finalResult.add(future.get()); //4
  }

  System.out.println(finalResult);
  }
  public static Integer add(int a, int b) {
      return a + b;

  }
  public static Integer multiply(int result) {
      return result * 15;
  }

There is no external thread to orchestrate the switching of tasks from one thread to another.
No blocking at any point until we just require the result, which is at line number 4. All 10 processes are happening in parallel,
and under each process, when the first task is finished by a thread, it is passed to another thread with the thenApplyAsync method.

///
7.What do you understand by inter-thread communication?
inter-thread communication is nothing but the process of communication between synchronized threads.
It is used to avoid thread polling in Java.
inter-thread communication can be achieved by wait(), notify(), and notifyAll() methods.

///
8.What is the purpose of the wait() method in Java?
It is the method provided by the Object class in Java. It is used for inter-thread communication in Java. java. lang.Object. wait(),
this method is used to pause the current thread and wait until another thread does not call the notify() or notifyAll() method.

///
9.Why must the wait() method be called from the synchronized block
We have to call the wait method otherwise it will throw java.lang.IllegalMonitorStateException type exception. Because of this, we need the wait() method for inter-thread communication with notify() and notifyAll() methods.
Hence It must be present in the synchronized block for proper and correct communication

//
10.What are the states in the lifecycle of a Thread?
    New:    In this state, a Thread class object is created using a new operator, but the thread is not alive. The thread doesn’t start until we call the start() method.
    Runnable:   In this state, the thread is run after calling the start() method. However, the thread is not yet selected by the thread scheduler.
    Running:    In this state, the thread scheduler picks the thread from the ready state.And the thread is running.
    Waiting/Blocked:    In this state, a thread is not running but still alive, or it is waiting for the other thread to finish.
    Dead/Terminated:    A thread is in terminated or dead state when the run() method exits.

///
11. What is context switching?
It is the state of the process (or thread) is stored so that it can be restored.
The execution can be resumed from the same point after that. Context switching provides multiple processes to share the same CPU.

///
12. Differentiate between the Thread class and Runnable interface for creating a Thread.
    The thread can be created by extending the Thread class
    The thread can be created by implementing the Runnable interface

///
13. What does join() method?
This method waits for a thread to die. It occurred the currently running threads to stop executing until the thread it joins with completes its task.
The join() method is overloaded in the Thread class in the following ways.

    The public void join() method throws InterruptedException.
    The public void join(long milliseconds) method throws InterruptedException.

15. What is the difference between wait() and sleep() method?
wait():

    Used for inter-thread communication.
    Causes the current thread to wait until it is notified (notify() or notifyAll()) by another thread.
    Typically used within synchronized blocks or methods.

sleep():

    Pauses the execution of the current thread for a specified amount of time.
    Does not involve synchronization or inter-thread communication.

16.  What’s the difference between notify() and notifyAll()?
notify():

    It sends a notification and wakes up only a single thread instead of multiple threads that are waiting on the object’s monitor.
    The notify() method is defined in the Object class, which is Java’s top-level class.
    It’s used to wake up only one thread that’s waiting for an object, and that thread then begins execution.
    The thread class notify() method is used to wake up a single thread.

notifyAll():

    It sends notifications wakes up all threads and allows them to compete for the object’s monitor instead of a single thread.
    The notifyAll() wakes up all threads that are waiting on this object’s monitor.
    A thread waits on an object’s monitor by calling one of the wait methods.
    The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object.

17. What do you mean by the ThreadLocal variable in Java?
 ThreadLocal variables are special kinds of variables created and provided by the Java ThreadLocal class. These variables are only allowed to be read and written by the same thread. Two threads cannot be able to see each other’s ThreadLocal variable,
  so even if they will execute the same code, then there won’t be any race condition and the code will be thread-safe.

18. What is the difference between 'synchronized method' and 'synchronized block'?
A synchronized method locks on the object (this) if it is an instance method, or on the Class object if it is a static method.
A synchronized block allows more granular control over the lock, enabling synchronization on any object or resource.
public class Example {
    private final Object lock = new Object();

    // Synchronized method
    public synchronized void syncMethod() {
        // critical section
    }

    // Synchronized block
    public void syncBlock() {
        synchronized (lock) {
            // critical section
        }
    }
}
19. What is a deadlock and how can you avoid it in Java?
A deadlock is a situation where two or more threads are blocked forever, waiting for each other. It can be avoided by following practices like:

    Avoiding nested locks.
    Using a timeout to acquire locks.
    Avoiding unnecessary locks.
    Lock ordering (acquiring locks in a consistent order).

20. What is the volatile keyword and how is it used in Java?
The volatile keyword in Java is used to mark a Java variable as "being stored in main memory."
It ensures that the value of the variable is always read from and written to the main memory, not from a thread's local cache.

public class VolatileExample {
    private volatile boolean flag = true;

    public void method() {
        while (flag) {
            // do something
        }
    }

    public void stop() {
        flag = false;
    }
}

21 .What is the ThreadLocal class and how is it used?
ThreadLocal provides thread-local variables. Each thread accessing such a variable has its own,
independently initialized copy of the variable. ThreadLocal can be used to avoid sharing state between threads.

public class ThreadLocalExample {
    private static final ThreadLocal<Integer> threadLocalValue = ThreadLocal.withInitial(() -> 1);

    public int getValue() {
        return threadLocalValue.get();
    }

    public void setValue(int value) {
        threadLocalValue.set(value);
    }

    public static void main(String[] args) {
        ThreadLocalExample example = new ThreadLocalExample();

        Runnable task = () -> {
            System.out.println(Thread.currentThread().getName() + " initial value: " + example.getValue());
            example.setValue(example.getValue() * 2);
            System.out.println(Thread.currentThread().getName() + " modified value: " + example.getValue());
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);

        thread1.start();
        thread2.start();
    }
}

22. Explain Callable and Future in Java.
Callable is similar to Runnable but can return a result and throw a checked exception. Future represents the result of an asynchronous computation,
 allowing you to check if the computation is complete, retrieve the result, and cancel the computation.

 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;

 public class CallableFutureExample {
     public static void main(String[] args) {
         ExecutorService executor = Executors.newSingleThreadExecutor();

         Callable<Integer> task = () -> {
             // simulate long-running task
             Thread.sleep(2000);
             return 123;
         };

         Future<Integer> future = executor.submit(task);

         try {
             // do something else
             System.out.println("Result: " + future.get()); // blocks until the result is available
         } catch (InterruptedException | ExecutionException e) {
             e.printStackTrace();
         } finally {
             executor.shutdown();
         }
     }
 }
////
23. Explain the ForkJoinPool and RecursiveTask in Java.
ForkJoinPool is designed for parallel processing by breaking tasks into smaller pieces using the fork/join framework.
RecursiveTask is a subclass of ForkJoinTask used to define tasks that return a result.

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

public class ForkJoinExample {
    static class FibonacciTask extends RecursiveTask<Integer> {
        private final int n;

        FibonacciTask(int n) {
            this.n = n;
        }

        @Override
        protected Integer compute() {
            if (n <= 1) return n;
            FibonacciTask f1 = new FibonacciTask(n - 1);
            f1.fork(); // asynchronously execute
            FibonacciTask f2 = new FibonacciTask(n - 2);
            return f2.compute() + f1.join(); // wait for result
        }
    }

    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool();
        FibonacciTask task = new FibonacciTask(10);
        int result = pool.invoke(task);
        System.out.println("Fibonacci(10) = " + result);
    }
}
///
24. What is Future in Java?
    Future is a mechanism to represent the result of an asynchronous computation in Java. It is part of the java.util.concurrent package
    How It Works

        You submit a task to an ExecutorService.
        The ExecutorService runs the task in the background.
        A Future object is returned immediately to represent the result of the task

    Common Methods of Future::
        1. get()
        Explanation:

        The get() method blocks the calling thread until the computation represented by the Future is complete. Once the task completes,
        get() retrieves the result. If the task completes exceptionally (i.e., an exception is thrown during execution), it will throw an ExecutionException.

            When to Use: You would use get() when you need the result of a computation, and you are okay with the calling thread being
            blocked while waiting for the result.
            Blocking Behavior: The calling thread will wait and block at future.get() until the task finishes, and the result is returned.

        Real-Time Example:
        In this scenario, you're performing a computation that involves fetching data from a remote service.
        You want to block the calling thread and wait for the result of the computation to proceed further
            import java.util.concurrent.*;

            public class FutureExample {
                public static void main(String[] args) throws InterruptedException, ExecutionException {
                    ExecutorService executor = Executors.newFixedThreadPool(1);
                    Future<String> future = executor.submit(() -> {
                        Thread.sleep(2000); // Simulating a delay (e.g., waiting for a remote service)
                        return "Data from remote service";
                    });

                    // Blocks and waits until the result is ready
                    String result = future.get();
                    System.out.println(result); // Output: "Data from remote service"

                    executor.shutdown();
                }
            }
        Output:

        Data from remote service
        Explanation: The thread waits for the computation to finish.
        After 2 seconds of simulated processing (representing a delay, like fetching data), the result is returned and printed

        2. isDone()
           Explanation:

           The isDone() method checks if the task is completed. It returns true if the computation is finished, either through normal completion,
           cancellation, or failure (exception).

           When to Use: This method is useful when you want to check the progress of a task without blocking the thread. For example,
           you may have multiple tasks running concurrently, and you want to check if they have completed

           Real-Time Example:

           You have multiple tasks running concurrently, and you want to periodically check if any of them are finished without blocking the calling thread.
           The isDone() method is useful for this.
           import java.util.concurrent.*;

           public class FutureExample {
               public static void main(String[] args) throws InterruptedException, ExecutionException {
                   ExecutorService executor = Executors.newFixedThreadPool(1);
                   Future<String> future = executor.submit(() -> {
                       Thread.sleep(2000); // Simulating a delay
                       return "Data from remote service";
                   });

                   // Continuously checking if the task is done
                   while (!future.isDone()) {
                       System.out.println("Task is still running...");
                       Thread.sleep(500); // Check every 500ms
                   }

                   // Once isDone() returns true, we can get the result
                   String result = future.get();
                   System.out.println(result); // Output: "Data from remote service"

                   executor.shutdown();
               }
           }
           Output::

           Task is still running...
           Task is still running...
           Task is still running...
           Data from remote service

           Explanation: The thread checks if the task is done every 500 milliseconds.
           The message "Task is still running..." is printed multiple times before the task completes (after 2 seconds).
           Once the task is done, the result is printed.

        3. cancel(boolean mayInterrupt)
            Explanation:

            The cancel() method attempts to cancel the task. If the task is running, it may attempt to interrupt the task (if mayInterrupt is true).
            If the task is already completed or canceled, the method does nothing and returns false. If the task is successfully canceled, it returns true.

            When to Use: This method is useful when you want to cancel a task that is taking too long or is no longer necessary.
                Interrupting the Task: If mayInterrupt is true, it tries to interrupt the running task. If the task is a long-running I/O operation
                or computation, this will stop the task if it's designed to handle interrupts.

            Real-Time Example:
            Imagine you're running a long-running computation, and after some time, you decide it should be canceled
            (e.g., due to a timeout or change in business requirements). This is how you can cancel it

            import java.util.concurrent.*;

            public class FutureExample {
                public static void main(String[] args) throws InterruptedException, ExecutionException {
                    ExecutorService executor = Executors.newFixedThreadPool(1);
                    Future<String> future = executor.submit(() -> {
                        Thread.sleep(5000); // Simulating a long-running task
                        return "Data from remote service";
                    });

                    // Trying to cancel the task if it takes too long
                    if (!future.cancel(true)) {
                        System.out.println("Task could not be canceled");
                    } else {
                        System.out.println("Task was successfully canceled");
                    }

                    executor.shutdown();
                }
            }

        Output::
        Task was successfully canceled
        Explanation::
        The task is canceled after 1 second, even though it was supposed to run for 5 seconds.
        The cancel(true) attempts to interrupt the task, which succeeds in this case.
        The cancellation is confirmed with the message "Task was successfully canceled"

        4. isCancelled()
        Explanation:

        The isCancelled() method checks if the task was successfully canceled before it completed. It returns true if the task was canceled, otherwise false.

        When to Use: After attempting to cancel a task, you can use isCancelled() to confirm whether the task was successfully canceled or not.
            Use Case: If you're monitoring multiple tasks and one of them was canceled, this method helps you confirm the cancellation.

        Real-Time Example::
        You attempt to cancel a task and then check whether the cancellation was successful using isCancelled()
            import java.util.concurrent.*;

            public class FutureExample {
                public static void main(String[] args) throws InterruptedException, ExecutionException {
                    ExecutorService executor = Executors.newFixedThreadPool(1);
                    Future<String> future = executor.submit(() -> {
                        Thread.sleep(5000); // Simulating a long-running task
                        return "Data from remote service";
                    });

                    // Attempting to cancel the task
                    future.cancel(true);

                    if (future.isCancelled()) {
                        System.out.println("Task was successfully canceled");
                    } else {
                        System.out.println("Task was not canceled");
                    }

                    executor.shutdown();
                }
            }
        Output:
        Task was successfully canceled

        Explanation:
        The task is canceled before it finishes running (after 1 second).
        The cancellation is confirmed using isCancelled(), which prints the message "Task was successfully canceled"

25. What is CompletableFuture?
    CompletableFuture is a part of Java's concurrency framework introduced in Java 8, in the java.util.concurrent package.
    It represents an asynchronous computation that can be manually completed (or "set") at a later time, and it provides a
    flexible way to handle asynchronous tasks.

    In simpler terms, it allows you to write code that executes asynchronously while providing you with easy ways to manage and
    combine multiple asynchronous tasks. It extends the Future interface but adds more powerful capabilities to handle asynchronous
    tasks in a non-blocking and more readable manner.

    Key Features of CompletableFuture:

        Non-blocking Operations: Allows you to perform multiple tasks concurrently without blocking the main thread.
        Chaining: Supports chaining of multiple tasks that depend on the result of the previous one.
        Exception Handling: Provides built-in support for exception handling in asynchronous computations.
        Manual Completion: You can manually complete a CompletableFuture with a result or an exception, allowing more control.
        Combining Futures: You can combine multiple CompletableFuture instances in various ways (e.g., thenCombine(), allOf(), anyOf()).
        Composition: Supports combining multiple futures or chaining tasks to avoid nested callbacks, making it easier to handle complex workflows

    Problems CompletableFuture Solves

        Asynchronous Task Management:

        Problem with Future: When using Future, you're often stuck in a situation where you have to block the calling thread using get().
        This creates performance bottlenecks in multi-threaded applications, especially when you need to handle multiple independent tasks.
        Solution with CompletableFuture: CompletableFuture provides an easier way to manage multiple asynchronous tasks by allowing you to chain
        them and execute them without blocking. It also allows you to execute code when a task completes using methods like thenApply(),
        thenAccept(), or thenCompose(). These methods provide a non-blocking, more functional approach to asynchronous programming.

    2.Combining Multiple Asynchronous Tasks:

        Problem with Future: If you need to wait for several asynchronous tasks to finish and then combine the results, you would need complex
        logic or nested callbacks with Future. This leads to callback hell.
        Solution with CompletableFuture: CompletableFuture makes it easier to combine multiple asynchronous tasks using methods like thenCombine(),
        allOf(), and anyOf(). You can wait for all tasks to finish or combine their results in a clean, readable way.

    3.Manual Completion of Tasks:

        Problem with Future: A Future is automatically completed once the task is done, and you cannot manually complete it or handle special completion cases.
        Solution with CompletableFuture: With CompletableFuture, you can manually complete a task using complete() or completeExceptionally()
        if certain conditions are met, allowing for more control over the task's lifecycle.

    4.Exception Handling:

        Problem with Future: If an exception occurs during the computation of a Future, it is wrapped in an ExecutionException and is only
         accessible after calling get(). Handling exceptions becomes complex when you need to handle multiple asynchronous tasks.
        Solution with CompletableFuture: CompletableFuture provides methods like exceptionally() and handle() to handle exceptions in
        asynchronous computations. These methods allow you to provide fallback values or perform actions when an exception occurs,
         avoiding the need for explicit try-catch blocks.

    5.Readable and Maintainable Code:

        Problem with Future: Using Future for complex asynchronous tasks often leads to nested code and callback hell, especially when there are dependent tasks.
        Solution with CompletableFuture: With methods like thenApply(), thenCompose(), and thenCombine(), CompletableFuture allows for clean,
        readable, and maintainable code when dealing with multiple asynchronous tasks. It also supports functional-style programming,
        making the code more declarative and concise

    Methods:
        1. supplyAsync():: static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);
        Description:

        Executes the given Supplier asynchronously and returns a CompletableFuture representing the result.
        Real-Time Use Case:

        In an e-commerce platform, a product details page can be loaded asynchronously.
        You might want to load product details, images, and recommendations asynchronously

        import java.util.concurrent.*;

        public class CompletableFutureExample {
            public static void main(String[] args) throws ExecutionException, InterruptedException {
                ExecutorService executor = Executors.newFixedThreadPool(1);

                // Asynchronously fetching product details
                CompletableFuture<String> productDetails = CompletableFuture.supplyAsync(() -> {
                    try {
                        Thread.sleep(1000); // Simulating network call
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    return "Product Details: Laptop";
                }, executor);

                System.out.println(productDetails.get());  // Output: Product Details: Laptop
                executor.shutdown();
            }
        }

        Output::
        Product Details: Laptop

        Explanation::
        The supplyAsync() method runs the task asynchronously and returns a CompletableFuture. In this case, it simulates fetching product details

        2. thenApply() :: <U> CompletableFuture<U> thenApply(Function<? super T, ? extends U> fn);
            Description:

            Transforms the result of a CompletableFuture when it is completed. It allows chaining functions to be executed when the original task finishes.
            Real-Time Use Case:

            In the previous example, after fetching product details, you might want to apply a discount and display the discounted price

            import java.util.concurrent.*;
            import java.util.function.Function;

            public class CompletableFutureExample {
                public static void main(String[] args) throws ExecutionException, InterruptedException {
                    ExecutorService executor = Executors.newFixedThreadPool(1);

                    // Asynchronously fetching product details
                    CompletableFuture<String> productDetails = CompletableFuture.supplyAsync(() -> {
                        try {
                            Thread.sleep(1000); // Simulating network call
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        return "Product Details: Laptop";
                    }, executor);

                    // Applying a discount on the fetched product details
                    CompletableFuture<String> discountedProductDetails = productDetails.thenApply(details -> {
                        return details + " - Discounted Price: $900";
                    });

                    System.out.println(discountedProductDetails.get());  // Output: Product Details: Laptop - Discounted Price: $900
                    executor.shutdown();
                }
            }

            Output:
            Product Details: Laptop - Discounted Price: $900

            Explanation:
            Here, the thenApply() method transforms the result of the original CompletableFuture (which is the product details) by adding a discounted price

        3. thenCompose() :: <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletableFuture<U>> fn);
            Description:

            Chains two asynchronous operations where the result of the first operation is used to initiate a second operation. It's like performing two dependent async tasks.
            Real-Time Use Case:

            Once the product details are fetched, you need to fetch related recommendations. The result of the first task (product details) is passed to initiate the second task (fetching recommendations).
            Code Example:

            import java.util.concurrent.*;
            import java.util.function.Function;

            public class CompletableFutureExample {
                public static void main(String[] args) throws ExecutionException, InterruptedException {
                    ExecutorService executor = Executors.newFixedThreadPool(1);

                    // Asynchronously fetching product details
                    CompletableFuture<String> productDetails = CompletableFuture.supplyAsync(() -> {
                        try {
                            Thread.sleep(1000); // Simulating network call
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        return "Product Details: Laptop";
                    }, executor);

                    // Using thenCompose to fetch recommendations after getting product details
                    CompletableFuture<String> recommendations = productDetails.thenCompose(details -> {
                        return CompletableFuture.supplyAsync(() -> {
                            try {
                                Thread.sleep(1000); // Simulating recommendation fetching
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            return "Recommendations: Mouse, Keyboard";
                        }, executor);
                    });

                    System.out.println(recommendations.get());  // Output: Recommendations: Mouse, Keyboard
                    executor.shutdown();
                }
            }

            Output::
            Recommendations: Mouse, Keyboard

            Explanation::
            thenCompose() allows us to chain dependent asynchronous tasks. The second task (fetching recommendations)
            starts only after the first one (fetching product details) is complete

        4. thenAccept() :: void thenAccept(Consumer<? super T> action);
            Description:

            Similar to thenApply(), but it doesn't return a new CompletableFuture. It performs an action (a Consumer) with the result of the computation.
            Real-Time Use Case:

            You may need to log the result of the product details fetch operation without further modifying the data

            import java.util.concurrent.*;
            import java.util.function.Consumer;

            public class CompletableFutureExample {
                public static void main(String[] args) throws ExecutionException, InterruptedException {
                    ExecutorService executor = Executors.newFixedThreadPool(1);

                    // Asynchronously fetching product details
                    CompletableFuture<String> productDetails = CompletableFuture.supplyAsync(() -> {
                        try {
                            Thread.sleep(1000); // Simulating network call
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        return "Product Details: Laptop";
                    }, executor);

                    // Consuming the result without returning a new value
                    productDetails.thenAccept(details -> {
                        System.out.println("Logging: " + details); // Logging the product details
                    });

                    executor.shutdown();
                }
            }

            Output::
            Logging: Product Details: Laptop

            Explanation::
            The thenAccept() method is used here to simply log the product details, without returning any result.

        5. exceptionally() :: CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> handler);
            Description:

            Handles exceptions in asynchronous computations. If the computation fails, it will handle the exception and return a fallback value.
            Real-Time Use Case:

            If fetching product details fails, you might want to provide a default product message or retry the operation

            import java.util.concurrent.*;
            import java.util.function.Function;

            public class CompletableFutureExample {
                public static void main(String[] args) throws ExecutionException, InterruptedException {
                    ExecutorService executor = Executors.newFixedThreadPool(1);

                    // Asynchronously fetching product details with a failure scenario
                    CompletableFuture<String> productDetails = CompletableFuture.supplyAsync(() -> {
                        if (true) { // Simulating an error
                            throw new RuntimeException("Failed to fetch product details");
                        }
                        return "Product Details: Laptop";
                    }, executor);

                    // Handling the exception and providing a fallback value
                    CompletableFuture<String> fallback = productDetails.exceptionally(ex -> {
                        return "Default Product: Placeholder";
                    });

                    System.out.println(fallback.get());  // Output: Default Product: Placeholder
                    executor.shutdown();
                }
            }

            Output::
            Default Product: Placeholder

            Explanation::
            exceptionally() catches the exception and provides a fallback value if something goes wrong during the asynchronous computation

        6.join():: T join();
            Description:

            Blocks until the computation completes and retrieves the result. Unlike get(), join() wraps any exception in a CompletionException instead of ExecutionException.
            Real-Time Use Case:

            You may want to block the thread and wait for the result of multiple independent asynchronous tasks and then combine the results

            import java.util.concurrent.*;

            public class CompletableFutureExample {
                public static void main(String[] args) {
                    ExecutorService executor = Executors.newFixedThreadPool(1);

                    // Asynchronously fetching product details
                    CompletableFuture<String> productDetails = CompletableFuture.supplyAsync(() -> {
                        try {
                            Thread.sleep(1000); // Simulating network call
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        return "Product Details: Laptop";
                    }, executor);

                    // Using join() to wait for the result
                    System.out.println(productDetails.join());  // Output: Product Details: Laptop

                    executor.shutdown();
                }
            }
            output::
            Product Details: Laptop

            Explanation:
            The join() method waits until the result is available and returns it. If an exception occurs, it wraps it in a CompletionException

26. Differences Between shutdown() and shutdownNow()
    Explanation:
    ExecutorService provides methods to manage thread pools:

    1.shutdown():
        Prevents new tasks from being submitted.
        Allows currently running tasks to complete.

    2. shutdownNow():
        Attempts to stop all running tasks immediately.
        Interrupts threads performing blocking operations.

27. Stopping Threads in Java
        Preferred Method: Always use graceful termination to stop threads. This can be achieved using techniques like:

        Volatile flags: Threads monitor a shared flag to exit safely.
        Interrupt mechanism: Especially useful for stopping threads in blocking operations (e.g., sleep() or wait()).

      2. Avoid Thread.stop(): It is unsafe and deprecated as it can lead to inconsistent states, resource corruption, and deadlocks.

      Real-World Scenarios:
        Background services (e.g., batch processing jobs) often require graceful shutdown to ensure resources are released and processes are not left incomplete.
        Thread pools managed via ExecutorService provide controlled shutdown methods (shutdown() and shutdownNow()) for safe task management.

        Key Takeaway: Ensure that thread termination is controlled, predictable, and resource-safe. This practice not only prevents application instability but also maintains the integrity of shared resources


28. Suppose you have 2 threads. One of them prints (1,2,3…) and the other one prints (A,B,C,..). How will you ensure that they run in a sequence, so that it prints (1,A,2,B…)?
    To achieve this sequence of alternating outputs (1, A, 2, B, ...) from two threads, we can use synchronization mechanisms like a shared lock (ReentrantLock or synchronized) and a condition variable (wait/notify) to coordinate the execution of the threads.

    Here's how we can implement this in Java:
    class AlternatingPrinter {

      private final Object lock = new Object();
      private boolean numberTurn = true; // Indicates whether it's the number thread's turn

      public static void main(String[] args) {
            AlternatingPrinter printer = new AlternatingPrinter();
            Thread numberThread = new Thread(() -> printer.printNumbers());
            Thread letterThread = new Thread(() -> printer.printLetters());
            numberThread.start();
            letterThread.start();
        }
       public void printNumbers() {
            for (int i = 1; i <= 26; i++) { // Adjust the range as needed
                synchronized (lock) {
                    while (!numberTurn) {
                        try {
                            lock.wait(); // Wait until it's this thread's turn
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                    System.out.print(i + " ");
                    numberTurn = false; // Pass the turn to the letter thread
                    lock.notifyAll(); // Notify the waiting thread
                }
            }
        }
       public void printLetters() {
            for (char c = 'A'; c <= 'Z'; c++) { // Adjust the range as needed
                synchronized (lock) {
                    while (numberTurn) {
                        try {
                            lock.wait(); // Wait until it's this thread's turn
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                    System.out.print(c + " ");
                    numberTurn = true; // Pass the turn to the number thread
                    lock.notifyAll(); // Notify the waiting thread
                }
            }
        }
    }

